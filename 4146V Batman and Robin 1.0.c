#pragma config(Sensor, in1,    armAngle,       sensorPotentiometer)
#pragma config(Sensor, in2,    batmanAngle,    sensorPotentiometer)
#pragma config(Sensor, in3,    autoSwitch,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           robinRDrive,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           batmanLeftDrive, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           batmanRightDrive, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           batmanLLift,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           batmanRLift,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           robinRTopLift, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           robinRBottomLift, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           robinLTopLift, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           robinLBottomLift, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          robinLDrive,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// robin low is 4000 // new max low is 2600 // new low 3200
//robin hight is 1800 // new max hight is 400 // new high 400?
// batman low is 150
//batman high is 2200

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

void batmanDrive(int leftD, int rightD){
motor[batmanLeftDrive] = leftD;
motor[batmanRightDrive] = rightD;
}

void robinDrive(int leftD, int rightD){
motor[robinLDrive] = leftD;
motor[robinRDrive] = rightD;
}

void batmanArm(int lArm, int rArm) {
motor[batmanLLift] = lArm;
motor[batmanRLift] = rArm;
}

void robinArm(int tL, int bL, int tR, int bR) {
motor[robinLTopLift] = tL;
motor[robinLBottomLift] = bL;
motor[robinRTopLift] = tR;
motor[robinRBottomLift] = bR;
}

void robinDriveStraight (int l, int r){
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;

	while(SensorValue[rightEncoder] < r && SensorValue[leftEncoder] > l) {
		if(abs(SensorValue[rightEncoder]) == abs(SensorValue[leftEncoder])) {
			robinDrive(110, 110);
		}
		if(abs(SensorValue[rightEncoder]) > abs(SensorValue[leftEncoder])) {
			motor[robinLDrive] = 110;
			motor[robinRDrive] = 100;
		}
		if(abs(SensorValue[rightEncoder]) < abs(SensorValue[leftEncoder])) {
			motor[robinLDrive] = 100;
			motor[robinRDrive] = 110;
		}
	}
}

//Task for robin in Auto
task RobinAuto ()
{
	//robin backs up from the fence
	robinDrive(-100,-100);
	wait1Msec(1000);
	robinDrive(0,0);

	SensorValue[armAngle] = 0;
	//motor[robinRDrive] = 100;
	//waitUntil(SensorValue[rightEncoder] >= 1300);
	//while(SensorValue[rightEncoder] < 500 && SensorValue[leftEncoder] < 500) {

	//robin turns
	robinDrive(-100, 100);
	wait1Msec(650);
	//}
	robinDrive(0, 0);
	//robin hits the wall
	//1300 encoder value
	robinDrive(100, 100);
	wait1Msec(1750);
	robinDrive (0, 0);

	//turns to face away from the fence
	SensorValue[leftEncoder] = 0;
	while(SensorValue[leftEncoder] < 800) {
		robinDrive(-100, 0);
	}
	robinDrive(0,0);
	//700 left
	//600

	//lower arm
	robinArm(-50, -50, -50, -50);
	waitUntil(SensorValue[armAngle] >= 3100);
	robinArm(0,0,0,0);

	//drive forward to pick up stars
	robinDriveStraight(-1050, 1050);
	robinDrive(0,0);

	//robin picks up stars
	//robinArm(50, 50, 50, 50);
	//waitUntil(SensorValue[armAngle] <= 2100);
	//robinArm(10,10,10,10);

	robinArm(50, 50, 50, 50);
	//waitUntil(SensorValue[armAngle] <= 2500);
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	robinDrive(-120, -120);
	waitUntil(SensorValue[armAngle] <= 2100);
	robinArm(10,10,10,10);
	waitUntil(SensorValue[leftEncoder] >= 2000 && SensorValue[rightEncoder] <= -2000);
	robinDrive(0,0);


	//robin drives backwards to the fence
	//SensorValue[leftEncoder] = 0;
	//SensorValue[rightEncoder] = 0;
	//robinDrive(-100, -100);
	//waitUntil(SensorValue[leftEncoder] >= 1800 && SensorValue[rightEncoder] <= -1800);
	//robinDrive(0,0);

	//dumps stars over the fence
	robinArm(80,80,80,80);
	waitUntil(SensorValue[armAngle] <= 550);
	robinArm(-50,-50,-50,-50);
	waitUntil(SensorValue[armAngle] >= 3100);
	robinArm(0,0,0,0);

}

//Task for batman in Auto
task BatmanAuto ()
{
	//batman turns to the direction of the cube
	batmanDrive(35,-35);
	wait1Msec(1100);
	batmanDrive(0,0);

	//batman's arm lowers to ground level
	batmanArm(-20,-20);
	waitUntil(SensorValue[batmanAngle]<= 1000);
	batmanArm(0,0);

	//batman moves forward and back to flip the scooper down
/*	batmanDrive(30,30);
	wait1Msec(400);
	batmanDrive(0,0);

	batmanDrive(-30,-30);
	wait1Msec(300);
	batmanDrive(0,0);
*/
	batmanDrive(100,100);
	wait1Msec(1700);
	batmanDrive(0,0);

	batmanDrive(-100,-100);
	wait1Msec(500);
	batmanDrive(0,0);

/* batman fail
	//batman drives forward to unlock brakes
	batmanDrive(50,50);
	wait1Msec(800);
	batmanDrive(0,0);

	//batman drives backwards
	batmanDrive(-50,-50);
	wait1Msec(600);
	batmanDrive(0,0);
	wait1Msec(500);
	//batman turns to the direction of the stars
	batmanDrive(40,-40);
	wait1Msec(1600);
	batmanDrive(0,0);

	//batman waits
	batmanDrive(0,0);
	wait1Msec(500);
	batmanDrive(0,0);

  //batman backs up
	batmanDrive(-50,-50);
	wait1Msec(800);
	batmanDrive(0,0);

	//batman's arm lowers to ground level
	batmanArm(-30,-30);
	waitUntil(SensorValue[batmanAngle]<= 900);
	batmanArm(0,0);

	//batman moves forward and back to flip the scooper down
	batmanDrive(100,100);
	wait1Msec(400);
	batmanDrive(0,0);

	batmanDrive(-100,-100);
	wait1Msec(300);
	batmanDrive(0,0);

	//batman drives forward
	batmanDrive(100,100);
	wait1Msec(2000);
	batmanDrive(0,0);

	//batman lifts scooper
	batmanArm(60,60);
	waitUntil(SensorValue[batmanAngle]>= 1600);
	batmanArm(10,10);

*/

}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	//////////////////////////Robin and Batman//////////////////////////////////////
	if(SensorValue[autoSwitch] > 2000 && SensorValue[autoSwitch] < 3200) {
	//batman arm opens out
	batmanArm(100, 100);
	waitUntil(SensorValue[batmanAngle] >= 1700);
	batmanArm(10, 10);


	//robin drives forward
	robinDrive(100, 100);
	wait1Msec(800);
	robinDrive(0, 0);

	//robin arm goes up
/*	robinArm(30, 30, 30, 30);
	//wait1Msec(500);
	waitUntil(SensorValue[armAngle] <= 1100);
	robinArm(0,0,0,0);
	robinDriveStraight(-2400, 2400);
	robinDrive(0,0);
	*/
	robinArm(40, 40, 40, 40);
	//wait1Msec(500);
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	robinDrive(100, 100);
	waitUntil(SensorValue[armAngle] <= 1200);
	robinArm(0,0,0,0);
	waitUntil(SensorValue[leftEncoder] <= -2400 && SensorValue[rightEncoder] >= 2400);
	robinDrive(0,0);
	//robin drives forward to knock stars on fence
	//robinDrive(100, 100);
	//wait1Msec(3000);
	//robinDrive(0, 0);


	startTask(RobinAuto);
	startTask(BatmanAuto);
	}

	//////////////////////////Robin NO Batman///////////////////////////////
	 else if(SensorValue[autoSwitch] > 1000 && SensorValue[autoSwitch] < 2000) {
		//batman arm opens out
	batmanArm(100, 100);
	waitUntil(SensorValue[batmanAngle] >= 1700);
	batmanArm(10, 10);


	//robin drives forward
	robinDrive(100, 100);
	wait1Msec(800);
	robinDrive(0, 0);

	//robin arm goes up
/*	robinArm(30, 30, 30, 30);
	//wait1Msec(500);
	waitUntil(SensorValue[armAngle] <= 1100);
	robinArm(0,0,0,0);
	robinDriveStraight(-2400, 2400);
	robinDrive(0,0);
	*/
	robinArm(40, 40, 40, 40);
	//wait1Msec(500);
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	robinDrive(100, 100);
	waitUntil(SensorValue[armAngle] <= 1200);
	robinArm(0,0,0,0);
	waitUntil(SensorValue[leftEncoder] <= -2400 && SensorValue[rightEncoder] >= 2400);
	robinDrive(0,0);
	//robin drives forward to knock stars on fence
	//robinDrive(100, 100);
	//wait1Msec(3000);
	//robinDrive(0, 0);


	startTask(RobinAuto);

	}
	////////////////////////////No Auto///////////////////////////////////////
	if(SensorValue[autoSwitch] > 3600) {

	}
//AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
//startTask(autonomous);
//8while(true){}
// User control code here, inside the loop
stopTask(RobinAuto);
stopTask(BatmanAuto);

	while(true)
	{
		//Assigns robin's drive to main joystick controls.
		motor[robinLDrive] = vexRT[Ch3];
		motor[robinRDrive] = vexRT[Ch2];

		//if potentiometer values is greater than 400, when you press button 6U, robin's arm will go up.
		if (vexRT[Btn6U] == 1 && SensorValue[armAngle] > 400) {
			motor[robinLTopLift] = 100;
			motor[robinLBottomLift] = 100;
			motor[robinRTopLift] = 100;
			motor[robinRBottomLift] = 100;
		}

		//if potentiometer values is less than 2200, when you press button 6D, robin's arm will go down.
		else if (vexRT[Btn6D] == 1 && SensorValue[armAngle] < 3200) {
			motor[robinLTopLift] = -100;
			motor[robinLBottomLift] = -100;
			motor[robinRTopLift] = -100;
			motor[robinRBottomLift] = -100;
		}
  	//robin's arm will continue to apply power when not moving.
 		else {
			motor[robinLTopLift] = 10;
			motor[robinLBottomLift] = 10;
			motor[robinRTopLift] = 10;
			motor[robinRBottomLift] = 10;
		}

		//Assigns batman's drive to partner joystick controls.
		motor[batmanLeftDrive] = vexRT[Ch3Xmtr2];
		motor[batmanRightDrive] = vexRT[Ch2Xmtr2];

		//if potentiometer values is less than 2400, when you press button 6U (partner), batman's arm will go up.
		if (vexRT[Btn6UXmtr2] == 1 && SensorValue[batmanAngle] < 2400) {
		motor[batmanLLift] = 100;
		motor[batmanRLift] = 100;
		}

		//if potentiometer values is greater than 200, when you press button 6D (partner), batman's arm will go down.
		else if (vexRT[Btn6DXmtr2] == 1 && SensorValue[batmanAngle] > 200) {
		motor[batmanLLift] = -100;
		motor[batmanRLift] = -100;
		}

		//batman's arm will continue to apply power when not moving.
		else {
		motor[batmanLLift] = 10;
		motor[batmanRLift] = 10;
		}

		wait1Msec(25);
	}
}
