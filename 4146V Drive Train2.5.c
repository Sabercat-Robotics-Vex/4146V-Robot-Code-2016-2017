#pragma config(Sensor, in1,    liftAngle,      sensorPotentiometer)
#pragma config(Motor,  port1,           backRightMotor, tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           backLeftMotor, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           frontRightMotor, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           frontLeftMotor, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           rightArmY,     tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           rightArmB,     tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           leftArmY,      tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftArmB,      tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           sideDrive,     tmotorVex393TurboSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Arm at floor level = 55
   Maximum height 2416
   Soft stop at 2300
   Carry = 400
   tall fence push = 1500
   low fence push = 1300
*/
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//Global Variables
float pidArmRequest;


task pidLiftControl(){

	float pidSensorCurrentValue;
 	float pidError;
 	float pidDrive;
	float pid_Kp = 0.5;

 while(true)
 	{
   //get the current sensor value
 		pidSensorCurrentValue = SensorValue[liftAngle];

 		//calculate error
 		pidError = pidArmRequest - pidSensorCurrentValue;

 		//calculate drive
 		pidDrive = (pid_Kp * pidError);

 		//limit drive
 		if(pidDrive > 127 )
 			pidDrive = 127;
 		if(pidDrive < (-127) )
 			pidDrive = (-127);

 		//send to motor
 		motor[rightArmY] = pidDrive;
 		motor[rightArmB] = pidDrive;
 		motor[leftArmY] = pidDrive;
 		motor[leftArmB] = pidDrive;

 		wait1Msec(25);

	}

}



void Arm(int rArmY, int rArmB, int lArmY, int lArmB)
{
	motor[rightArmY] = rArmY;
	motor[rightArmB] = rArmB;
	motor[leftArmY] = lArmY;
	motor[leftArmB] = lArmB;
	wait1Msec(25);
}

void Drive(int fLeft, int bLeft, int fRight, int bRight)
{
	motor[frontLeftMotor] = fLeft;
	motor[backLeftMotor] = bLeft;
	motor[frontRightMotor] = fRight;
	motor[backRightMotor] = bRight;
	wait1Msec(25);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  //Flip down the scoop
	Drive(100,100,100,100);
  wait1Msec(500);
  Drive(-100,-100,-100,-100);
  wait1Msec(600);

  Arm(50,50,50,50);
  wait1Msec(500);
  //waitUntil(SensorValue[liftAngle]) >= 1400;
  Arm(5,5,5,5);
  Drive(100,100,100,100);
  wait10Msec(10);
  Drive(0,0,0,0);
  wait1Msec(1000);

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////


	// User control code here, inside the loop

task usercontrol()
{
	bool armMoving = false;
while(true)
	{

	//drive train
	motor[frontLeftMotor] = vexRT[Ch3];
	motor[backLeftMotor] = vexRT[Ch3];
	motor[frontRightMotor] = vexRT[Ch2];
	motor[backRightMotor] = vexRT[Ch2];
	motor[sideDrive] = vexRT[Ch1];
	//arm controls

	if((vexRT[Btn6U] == 1)&&(SensorValue[liftAngle] < 2300)){
		Arm(127,127,127,127);
		armMoving = true;
		//motor[rightArmY] = 127;
		//motor[rightArmB] = 127;
		//motor[leftArmY] = 127;
		//motor[leftArmB] = 127;
		}
	else if((vexRT[Btn6U] == 1)&&(SensorValue[liftAngle] > 2300)){
		Arm(0,0,0,0);
		//motor[rightArmY] = 0;
		//motor[rightArmB] = 0;
		//motor[leftArmY] = 0;
		//motor[leftArmB] = 0;
		}
	else if((vexRT[Btn6D] == 1)&& (SensorValue[liftAngle] > 50)){
		Arm(-100,-100,-100,-100);
	  armMoving = true;
		//motor[rightArmY] = -100;
		//motor[rightArmB] = -100;
		//motor[leftArmY] =  -100;
		//motor[leftArmB] =  -100;
		}
	else if((vexRT[Btn6D] == 1)&& (SensorValue[liftAngle] < 50)){
		Arm(0,0,0,0);
		//motor[rightArmY] = 0;
		//motor[rightArmB] = 0;
		//motor[leftArmY] =  0;
		//motor[leftArmB] =  0;
		}
	else
		{
			Arm(10,10,10,10);
			//motor[rightArmY] = 10;
			//motor[rightArmB] = 10;
			//motor[leftArmY] =  10;
			//motor[leftArmB] =  10;
		}



 	if((vexRT[Btn8D] == 1) && (SensorValue[liftAngle] > 60)){
    Arm(-100,-100,-100,-100);
 		//motor[rightArmY] = -100;
		//motor[rightArmB] = -100;
		//motor[leftArmY] =  -100;
		//motor[leftArmB] =  -100;
		waitUntil(SensorValue[liftAngle] <= 60);
		Arm(0,0,0,0);
		//motor[rightArmY] = 0;
		//motor[rightArmB] = 0;
		//motor[leftArmY] =  0;
		//motor[leftArmB] =  0;
		}

	if((vexRT[Btn8L] == 1) && (SensorValue[liftAngle] > 500)){
    Arm(-100,-100,-100,-100);
		//motor[rightArmY] = -100;
		//motor[rightArmB] = -100;
		//motor[leftArmY] =  -100;
		//motor[leftArmB] =  -100;
		waitUntil(SensorValue[liftAngle] < 500);
		Arm(0,0,0,0);
		//motor[rightArmY] = 0;
		//motor[rightArmB] = 0;
		//motor[leftArmY] =  0;
		//motor[leftArmB] =  0;
	}
	else if((vexRT[Btn8L] == 1) && (SensorValue[liftAngle] < 400)){
    Arm(100,100,100,100);
		//motor[rightArmY] = 100;
		//motor[rightArmB] = 100;
		//motor[leftArmY] =  100;
		//motor[leftArmB] =  100;
		waitUntil(SensorValue[liftAngle] > 400);
		Arm(0,0,0,0);
		//motor[rightArmY] = 0;
		//motor[rightArmB] = 0;
		//motor[leftArmY] =  0;
		//motor[leftArmB] =  0;
	}
	else if ((vexRT[Btn8U] == 1) && (SensorValue[liftAngle] < 2000)){
		Arm(127,127,127,127);
		waitUntil(SensorValue[liftAngle] > 2000);
		Arm(-100,-100,-100,-100);
		wait1Msec(500);
	}

	else
	{
		if (!armMoving) {
		Arm(10,10,10,10);
		}
	}
	armMoving = false;
	wait1Msec(25);
	}
}
